/***************************************************************************************
*  Program Name:    PhysBody.cpp                                                       *         
*  Name:            Bryan Sweeney                                                      *
*  Date:            January 22, 2013                                                   *
*  Description:     This program holds the information necessary for the Physics Core  *
*                    to use,  this is done through the PhysWorld entity                *
*  Update:          Jen 1/30/2013                                                      *
*                                                                                      *
***************************************************************************************/


#include "physicsengine\physbody.h"
#include <memory.h>
#include <assert.h>

using namespace PhysicsEngine;

/************************************************************
*  I N T E R N A L  H E L P E R   F U N C T I O N S        **
************************************************************/

/*Internal fucnation to perform a transformation on an inertia
tensor by a quaternion.  Note: Code generated by code generation
software*/


static inline void _transInertiaTensor(Matrix3 &iitWorld,
                                           const Quaternion &q,
                                           const Matrix3 &iitBody,
                                           const Matrix4 &rotmat)

{
    double t4 = rotmat.data[0]*iitBody.data[0]+
        rotmat.data[1]*iitBody.data[3]+
        rotmat.data[2]*iitBody.data[6];
    double t9 = rotmat.data[0]*iitBody.data[1]+
        rotmat.data[1]*iitBody.data[4]+
        rotmat.data[2]*iitBody.data[7];
    double t14 = rotmat.data[0]*iitBody.data[2]+
        rotmat.data[1]*iitBody.data[5]+
        rotmat.data[2]*iitBody.data[8];
    double t28 = rotmat.data[4]*iitBody.data[0]+
        rotmat.data[5]*iitBody.data[3]+
        rotmat.data[6]*iitBody.data[6];
    double t33 = rotmat.data[4]*iitBody.data[1]+
        rotmat.data[5]*iitBody.data[4]+
        rotmat.data[6]*iitBody.data[7];
    double t38 = rotmat.data[4]*iitBody.data[2]+
        rotmat.data[5]*iitBody.data[5]+
        rotmat.data[6]*iitBody.data[8];
    double t52 = rotmat.data[8]*iitBody.data[0]+
        rotmat.data[9]*iitBody.data[3]+
        rotmat.data[10]*iitBody.data[6];
    double t57 = rotmat.data[8]*iitBody.data[1]+
        rotmat.data[9]*iitBody.data[4]+
        rotmat.data[10]*iitBody.data[7];
    double t62 = rotmat.data[8]*iitBody.data[2]+
        rotmat.data[9]*iitBody.data[5]+
        rotmat.data[10]*iitBody.data[8];

    iitWorld.data[0] = t4*rotmat.data[0]+
        t9*rotmat.data[1]+
        t14*rotmat.data[2];
    iitWorld.data[1] = t4*rotmat.data[4]+
        t9*rotmat.data[5]+
        t14*rotmat.data[6];
    iitWorld.data[2] = t4*rotmat.data[8]+
        t9*rotmat.data[9]+
        t14*rotmat.data[10];
    iitWorld.data[3] = t28*rotmat.data[0]+
        t33*rotmat.data[1]+
        t38*rotmat.data[2];
    iitWorld.data[4] = t28*rotmat.data[4]+
        t33*rotmat.data[5]+
        t38*rotmat.data[6];
    iitWorld.data[5] = t28*rotmat.data[8]+
        t33*rotmat.data[9]+
        t38*rotmat.data[10];
    iitWorld.data[6] = t52*rotmat.data[0]+
        t57*rotmat.data[1]+
        t62*rotmat.data[2];
    iitWorld.data[7] = t52*rotmat.data[4]+
        t57*rotmat.data[5]+
        t62*rotmat.data[6];
    iitWorld.data[8] = t52*rotmat.data[8]+
        t57*rotmat.data[9]+
        t62*rotmat.data[10];
}


/* function that uses postion and orientation to create a 
transform matrix */



static inline void _calcTransformMatrix(Matrix4 &transformMatrix,
                                             const Vector3D &position,
                                             const Quaternion &orientation)
{
	transformMatrix.data[0] = 1-2*orientation.m_j*orientation.m_j-
        2*orientation.m_k*orientation.m_k;
    transformMatrix.data[1] = 2*orientation.m_i*orientation.m_j -
        2*orientation.m_r*orientation.m_k;
    transformMatrix.data[2] = 2*orientation.m_i*orientation.m_k +
        2*orientation.m_r*orientation.m_j;
    transformMatrix.data[3] = position.x;

    transformMatrix.data[4] = 2*orientation.m_i*orientation.m_j +
        2*orientation.m_r*orientation.m_k;
    transformMatrix.data[5] = 1-2*orientation.m_i*orientation.m_i-
        2*orientation.m_k*orientation.m_k;
    transformMatrix.data[6] = 2*orientation.m_j*orientation.m_k -
        2*orientation.m_r*orientation.m_i;
    transformMatrix.data[7] = position.y;

    transformMatrix.data[8] = 2*orientation.m_i*orientation.m_k -
        2*orientation.m_r*orientation.m_j;
    transformMatrix.data[9] = 2*orientation.m_j*orientation.m_k +
        2*orientation.m_r*orientation.m_i;
    transformMatrix.data[10] = 1-2*orientation.m_i*orientation.m_i-
        2*orientation.m_j*orientation.m_j;
    transformMatrix.data[11] = position.z;;
}


/*************************************************************
*  E N D   I N T E R N A L  H E L P E R   F U N C T I O N S **
**************************************************************/


/*The below function calculates the data within the object that
is needed for the collisions*/

void PhysBody::calculateObjectData()
{
	m_qOrientation.normalize();

	//need to get the transform matrix 

	_calcTransformMatrix(m_m4TransformMatrix, m_v3Position, m_qOrientation); //need to do in this file after calculateObjectData is complete

	//determine intertiaTensor

	_transInertiaTensor(    //need to do in this file after calculateObjectData is complete
		m_m3InverseInertiaTensorWorld,
		m_qOrientation,
		m_m3InverseInertiaTensor,
		m_m4TransformMatrix);
}



/*Main physics routine.. uses information within the collision and previous occurances
to calculate how the object is to react*/

void PhysBody::physicsIntegration (double dElapsedFrameTime)
{

	//check to see if the object can be impacted:

	if (!m_bIsInStatis) return;


	//determine the linear acceleration from the forces impacting the object

	m_v3AccelerationLastFrame = m_v3Acceleration;
	m_v3AccelerationLastFrame.addScaledVector(m_v3AccumulatedForce, dElapsedFrameTime);

	//determine angular acceleration based on any torque that occurs

	Vector3D angularAcceleration = m_m3InverseInertiaTensorWorld.transform(m_v3AccumulatedTorque);

	/*Now to see what the force impacts are to the existing velocities that are impacting
	the object.  The following must be calculated:
			linear veocity
			angular velocity
			impact of any drag				*/

	//Calculate new linear velocity

	m_v3Velocity.addScaledVector(m_v3AccelerationLastFrame, dElapsedFrameTime);

	//Calculate angularAcceleration from impacts of torque

	m_v3Rotation.addScaledVector(angularAcceleration, dElapsedFrameTime);

	//Calculate drag's impact on both velocity and rotation

	m_v3Velocity *= pow(m_dLinearDamping, dElapsedFrameTime);
	m_v3Rotation *= pow(m_dAngularDamping, dElapsedFrameTime);

/* we have calculated the new velocity and rotation.  We need to apply it
to the position of the body that was impacted by the physical forces.  
This requires:
		updating of linear postition
		updating of angular oposition
		normalize orientation
		clean up after ourselves*/

	//Update object's linear position
	m_v3Position.addScaledVector(m_v3Velocity, dElapsedFrameTime);

	//Update object's angular position
	m_qOrientation.calcOrientation(m_v3Rotation, dElapsedFrameTime);

	//normalize orientation and update with new position/orientation
	calculateObjectData();


	//clean up everything

	emptyAccumulators();

	/*update the motion energy and see if the object needs to be
	placed in statis*/


	if (m_bCanBePutInStatis)
	{
		double dCurrentMotion = m_v3Velocity.scalarProduct(m_v3Velocity) +
			m_v3Rotation.scalarProduct(m_v3Rotation);

		double dBias = pow(0.5, dElapsedFrameTime);
		m_dMotion = dBias*m_dMotion + (1-dBias)*dCurrentMotion;

		if (m_dMotion < statisFactor) setObjectStatis(false);
		else if (m_dMotion > 10 * statisFactor) m_dMotion = 10 * statisFactor;
	};
}

//Function to set the mass of the object
void PhysBody::setBodyMass(const double dMass)
{
	/*make sure that there is something in mass or bad things happen 
	in the next line*/
	assert(dMass !=0);
	PhysBody::m_dInverseMass = ((double)1.0)/dMass;
	}


//Function to get the mass of the object
double PhysBody::getBodyMass() const
{
	if (m_dInverseMass == 0)
	{
		return DBL_MAX;
	} else {
		return ((double)1.0)/m_dInverseMass;
	}
}


//function to set the inverse mass of the object
void PhysBody::setInverseBodyMass(const double m_dInverseBodyMass)
{
	PhysBody::m_dInverseMass=m_dInverseMass;
}



//function to get the inverse mass of the object
double PhysBody::getInverseBodyMass() const
{
	return m_dInverseMass;
}


//check to see if you have infinite mass

bool PhysBody::bodyHasFiniteMass() const
{
	return m_dInverseMass >= 0.0;
}


//Function to set the interia tensor
void PhysBody::setInertiaTensor(const Matrix3 &m_m3InertiaTensor)
{
	m_m3InverseInertiaTensor.setInverse(m_m3InertiaTensor);
}

//fucntion to return the inertia tensor

void PhysBody::getInertiaTensor(Matrix3 *inertiaTensor) const
{
	inertiaTensor->setInverse(m_m3InverseInertiaTensor);
}

//function to return the intertia tensor
Matrix3 PhysBody::getInertiaTensor() const
{
	Matrix3 m3It;
	getInertiaTensor(&m3It);
	return m3It;
}


//fucntion to get the inertia tensor in world coords
void PhysBody::getInertiaTensorWorld(Matrix3 *inertiaTensor) const
{
	inertiaTensor->setInverse(m_m3InverseInertiaTensorWorld);
}

//function to get the inertia tensor in world coords
Matrix3 PhysBody::getInertiaTensorWorld() const
{
	Matrix3 m3It;
	getInertiaTensor(&m3It);
	return m3It;
}

//function to set th inverse inertia tensro
void PhysBody::setInverseInertiaTensor (const Matrix3 &inverseInertiaTensor)
{
	
	PhysBody::m_m3InverseInertiaTensor = inverseInertiaTensor;
}

//fucntion to get the inverse inertia tensor
void PhysBody::getInverseInertiaTensor (Matrix3 *inverseInertiaTensor) const
{
	*inverseInertiaTensor = PhysBody::m_m3InverseInertiaTensor;
}

//function to geth the invser inertia tensor
Matrix3 PhysBody::getInverseInertiaTensor() const
{
    return m_m3InverseInertiaTensor;
}


//funtion to get the inverse inertia tensor in world coords
void PhysBody::getInverseInertiaTensorWorld(Matrix3 *inverseInertiaTensor) const
{
    *inverseInertiaTensor = m_m3InverseInertiaTensorWorld;
}


//functin to get the invser inertia tenstor in world coord
Matrix3 PhysBody::getInverseInertiaTensorWorld() 
{
    return m_m3InverseInertiaTensorWorld;
}


//function to set damping on the object (both linear and angular)

void PhysBody::setObjectDamping (const double linearDamping, 
	                             const double angularDamping)
{
	PhysBody::m_dLinearDamping = linearDamping;
	PhysBody::m_dAngularDamping = angularDamping;
}


//function to set linear damping only on an object
void PhysBody::setObjectLinearDamping (const double linearDamping)
{
	PhysBody::m_dLinearDamping = linearDamping;
}


//function to obtain linear damping impacting an object
double PhysBody::getObjectLinearDamping () 
{
	return m_dLinearDamping;
}

//function to set angular damping on an object
void PhysBody::setObjectAngularDamping (const double angularDamping)
{
	PhysBody::m_dAngularDamping = angularDamping;
}

//function to get angular damping that is effecting an object
double PhysBody::getObjectAngularDamping() const
{
	return m_dAngularDamping;
}


//function to set the body's position
void PhysBody::setBodyPosition(const Vector3D &position)
{
	PhysBody::m_v3Position = position;
}

//function to set body's postition by coords
void PhysBody::setBodyPosition ( double x, const double y, const double z)
{
	m_v3Position.x = x;
	m_v3Position.y = y;
	m_v3Position.z = z;
}

//function to obtain position
void PhysBody::getBodyPosition(Vector3D *position) const
{
	*position = PhysBody::m_v3Position;
}

//function to obtain position
Vector3D PhysBody::getBodyPosition() const
{
	return m_v3Position;
}


//function to set the orientation of an object
void PhysBody::setBodyOrientationQ(const Quaternion &orientation)
{
	PhysBody::m_qOrientation = orientation;
	PhysBody::m_qOrientation.normalize();
}

//function to set the oriention of an object with paramaters passed
void PhysBody::setBodyOrientation(const double r, const double i,
								  const double j, const double k)
{
	m_qOrientation.m_r = r;
	m_qOrientation.m_i = i;
	m_qOrientation.m_j = j;
	m_qOrientation.m_k = k;

	//now normalize the orientation
	m_qOrientation.normalize();
}


//function to get the orientation
void PhysBody::getBodyOrientation(Quaternion *orientation) const
{
	*orientation = PhysBody::m_qOrientation;
}


//function to get the orientation
Quaternion PhysBody::getBodyOrientation() const
{
	return m_qOrientation;
}

//fuction to get orientation and put it into a matrix
void PhysBody::getBodyOrientation(Matrix3 *matrix) const
{
	getBodyOrientation(matrix->data);
}

//function to get orientation into a matrix
void PhysBody::getBodyOrientation(double matrix[9]) const
{
    matrix[0] = m_m4TransformMatrix.data[0];
    matrix[1] = m_m4TransformMatrix.data[1];
    matrix[2] = m_m4TransformMatrix.data[2];

    matrix[3] = m_m4TransformMatrix.data[4];
    matrix[4] = m_m4TransformMatrix.data[5];
    matrix[5] = m_m4TransformMatrix.data[6];

    matrix[6] = m_m4TransformMatrix.data[8];
    matrix[7] = m_m4TransformMatrix.data[9];
    matrix[8] = m_m4TransformMatrix.data[10];
}


// function to transform matrix
void PhysBody::getTransform (Matrix4 *transform) const
{
	//using memcpy due to the matrix
    memcpy(transform, &m_m4TransformMatrix.data, sizeof(Matrix4));
}

//function to transform matrix[16]
void PhysBody::getTransform(double matrix[16]) const
{
    memcpy(matrix, m_m4TransformMatrix.data, sizeof(double)*12);
    matrix[12] = matrix[13] = matrix[14] = 0;
    matrix[15] = 1;
}


//function to perform the GLTransfrom
void PhysBody::getGLTransform(double matrix[16]) const
{
    matrix[0] = (double)m_m4TransformMatrix.data[0];
    matrix[1] = (double)m_m4TransformMatrix.data[4];
    matrix[2] = (double)m_m4TransformMatrix.data[8];
    matrix[3] = 0;

    matrix[4] = (double)m_m4TransformMatrix.data[1];
    matrix[5] = (double)m_m4TransformMatrix.data[5];
    matrix[6] = (double)m_m4TransformMatrix.data[9];
    matrix[7] = 0;

    matrix[8] = (double)m_m4TransformMatrix.data[2];
    matrix[9] = (double)m_m4TransformMatrix.data[6];
    matrix[10] = (double)m_m4TransformMatrix.data[10];
    matrix[11] = 0;

    matrix[12] = (double)m_m4TransformMatrix.data[3];
    matrix[13] = (double)m_m4TransformMatrix.data[7];
    matrix[14] = (double)m_m4TransformMatrix.data[11];
    matrix[15] = 1;
}

Matrix4 PhysBody::getTransform() const
{
    return m_m4TransformMatrix;
}


//functionto get a point in local space
Vector3D PhysBody::getPointInLocalSpace(const Vector3D &point) const
{
    return m_m4TransformMatrix.transformInverse(point);
}


//fucntion to get a point in world space
Vector3D PhysBody::getPointInWorldSpace(const Vector3D &point) const
{
    return m_m4TransformMatrix.transform(point);
}


//function to get direction in Local space
Vector3D PhysBody::getDirectionInLocalSpace(const Vector3D &direction) const
{
    return m_m4TransformMatrix.transformInverseDirection(direction);
}


//function to get direction in world space
Vector3D PhysBody::getDirectionInWorldSpace(const Vector3D &direction) const
{
    return m_m4TransformMatrix.transformDirection(direction);
}


//function to set velocity of an object
void PhysBody::setObjectVelocity(const Vector3D &velocity)
{
	PhysBody::m_v3Velocity = velocity;
}

//function to set velocity based on parameters
void PhysBody::setObjectVelocity(const double x, const double y, const double z)
{
	m_v3Velocity.x = x;
	m_v3Velocity.y = y;
	m_v3Velocity.z = z;
}

//funcation to get velocity as a vector
void PhysBody::getObjectVelocity( Vector3D *velocity) const
{
	*velocity = PhysBody::m_v3Velocity;
}

//function to get velocity
Vector3D PhysBody::getObjectVelocity() const
{
	return m_v3Velocity;
}


//function to increase velocity
void PhysBody::addVelocityToObject(const Vector3D &deltaVelocity)
{
	m_v3Velocity += deltaVelocity;
}


//function to set object roation
void PhysBody::setObjectRotation(const Vector3D &rotation)
{
    PhysBody::m_v3Rotation = rotation;
}


//fuunction to set rotation by paramaters
void PhysBody::setObjectRotation(const double x, const double y, const double z)
{
    m_v3Rotation.x = x;
    m_v3Rotation.y = y;
    m_v3Rotation.z = z;
}


//function to get roation as a vector
void PhysBody::getObjectRotation(Vector3D *rotation) const
{
    *rotation = PhysBody::m_v3Rotation;
}


//function to get rotation 
Vector3D PhysBody::getObjectRotation() const
{
    return m_v3Rotation;
}


//function to add to objects rotation
void PhysBody::addObjectRotation(const Vector3D &deltaRotation)
{
    m_v3Rotation += deltaRotation;
}


//get a object out of statis
void PhysBody::setObjectStatis(const bool awake)
{
	if (awake) {
		m_bIsInStatis = true;

		//need to add some motion or else back in statis it goes
		m_dMotion = statisFactor * 2.0;
	} else {
		m_bIsInStatis = false;
		m_v3Velocity.clear();
		m_v3Rotation.clear();
	}
}


//set that an object can go into statis
void PhysBody::setCanGoIntoStatis(const bool CanBePutInStatis)
{
	PhysBody::m_bCanBePutInStatis = CanBePutInStatis;

	if (!m_bCanBePutInStatis && !m_bIsInStatis) setObjectStatis();
}


//get acculmated acceleration for the object
void PhysBody::getAccumulatedAcceleration(Vector3D *acceleration) const
{
	*acceleration = m_v3AccelerationLastFrame;
}


//function to get accumulated accelartion
Vector3D PhysBody::getAccumulatedAcceleration() const
{
	return m_v3AccelerationLastFrame;
}


//clear all accumulators
void PhysBody::emptyAccumulators()
{
	m_v3AccumulatedForce.clear();
	m_v3AccumulatedTorque.clear();
}

//function to add force and take out of statis
void PhysBody::addForceToObject(const Vector3D &force)
{
	m_v3AccumulatedForce += force;
	m_bIsInStatis = true;
}



// function to add force at a body point
void PhysBody::addForceAtBodyPoint(const Vector3D &force,
                                    const Vector3D &point)
{
	//need to convert to world space
	Vector3D pt = getPointInWorldSpace(point);
	addForceAtPoint(force,pt);

	//wake it up
	m_bIsInStatis = true;
}

//add force to wold point
void PhysBody::addForceAtPoint(const Vector3D &force, const Vector3D &point)
{
	//conver to points that are in relation to center of mass
	Vector3D pt = point;
	pt -= m_v3Position;

	m_v3AccumulatedForce += force;
	m_v3AccumulatedTorque += pt % force;

	//wake up the object
	m_bIsInStatis = true;
}


//add torque to a body
void PhysBody::addTorqueToBody(const Vector3D &torque)
{
	m_v3AccumulatedTorque += torque;

	//wake up the object
	m_bIsInStatis = true;
}


//set the acceleration of an object
void PhysBody::setBodyAcceleration(const Vector3D &acceleration)
{
	PhysBody::m_v3Acceleration += acceleration;
}


//function to set acceleration by parameter
void PhysBody::setBodyAcceleration(const double x, const double y, const double z)
{
	m_v3Acceleration.x = x;
	m_v3Acceleration.y = y;
	m_v3Acceleration.z = z;
}


//obtain objects acelleration0
void PhysBody::getBodyAcceleration(Vector3D *acceleration) const
{
	*acceleration = PhysBody::m_v3Acceleration;
}


//obtain object's acceleration
Vector3D PhysBody::getBodyAcceleration() const
{
	return m_v3Acceleration;
}
